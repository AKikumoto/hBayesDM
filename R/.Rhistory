sv = exp(-1 * (gamma * delay)^s );
lines(delay, sv, type="l",xlim=c(0,520), ylim=c(0,1), ylab="", xlab="", col=gIdx)
}
gamma_all = seq(0.0005, 0.2, by = 0.01);
s_all = seq(0.005, 3.0, by = 0.05)
quartz()
plot(0, 0, xlim=c(0,520), ylim=c(0,1), type="l",
main = "CS (2 pars), gamma from 0.0005 to 0.3, s from 0.05 to 3.0")
gIdx
gamma = gamma_all[gIdx]
for (sIdx in 1:length(s_all)) {
s = s_all[sIdx]
sv = exp(-1 * (gamma * delay)^s );
lines(delay, sv, type="l",xlim=c(0,520), ylim=c(0,1), ylab="", xlab="", col=gIdx)
}
s_all = seq(0.0005, 3.0, by = 0.05)
quartz()
plot(0, 0, xlim=c(0,520), ylim=c(0,1), type="l",
main = "CS (2 pars), gamma from 0.0005 to 0.3, s from 0.05 to 3.0")
gamma = gamma_all[gIdx]
for (sIdx in 1:length(s_all)) {
s = s_all[sIdx]
sv = exp(-1 * (gamma * delay)^s );
lines(delay, sv, type="l",xlim=c(0,520), ylim=c(0,1), ylab="", xlab="", col=gIdx)
}
s_all = seq(0.0005, 5.0, by = 0.05)
gamma = gamma_all[gIdx]
for (sIdx in 1:length(s_all)) {
s = s_all[sIdx]
sv = exp(-1 * (gamma * delay)^s );
lines(delay, sv, type="l",xlim=c(0,520), ylim=c(0,1), ylab="", xlab="", col=gIdx)
}
quartz()
plot(0, 0, xlim=c(0,520), ylim=c(0,1), type="l",
main = "CS (2 pars), gamma from 0.0005 to 0.3, s from 0.05 to 3.0")
gamma = gamma_all[gIdx]
for (sIdx in 1:length(s_all)) {
s = s_all[sIdx]
sv = exp(-1 * (gamma * delay)^s );
lines(delay, sv, type="l",xlim=c(0,520), ylim=c(0,1), ylab="", xlab="", col=gIdx)
}
s_all = seq(0.0005, 1.0, by = 0.05)
quartz()
plot(0, 0, xlim=c(0,520), ylim=c(0,1), type="l",
main = "CS (2 pars), gamma from 0.0005 to 0.3, s from 0.05 to 3.0")
gamma = gamma_all[gIdx]
for (sIdx in 1:length(s_all)) {
s = s_all[sIdx]
sv = exp(-1 * (gamma * delay)^s );
lines(delay, sv, type="l",xlim=c(0,520), ylim=c(0,1), ylab="", xlab="", col=gIdx)
}
s_all = seq(0.0005, 2.0, by = 0.05)
gamma = gamma_all[gIdx]
for (sIdx in 1:length(s_all)) {
s = s_all[sIdx]
sv = exp(-1 * (gamma * delay)^s );
lines(delay, sv, type="l",xlim=c(0,520), ylim=c(0,1), ylab="", xlab="", col=gIdx)
}
gamma_all = seq(0.0005, 0.2, by = 0.01);
s_all = seq(0.0005, 2.0, by = 0.05)
quartz()
plot(0, 0, xlim=c(0,520), ylim=c(0,1), type="l",
main = "CS (2 pars), gamma from 0.0005 to 0.3, s from 0.05 to 3.0")
gamma = gamma_all[gIdx]
for (sIdx in 1:length(s_all)) {
s = s_all[sIdx]
sv = exp(-1 * (gamma * delay)^s );
lines(delay, sv, type="l",xlim=c(0,520), ylim=c(0,1), ylab="", xlab="", col=gIdx)
}
gamma
gamma = 0.1
plot(0, 0, xlim=c(0,520), ylim=c(0,1), type="l",
main = "CS (2 pars), gamma from 0.0005 to 0.3, s from 0.05 to 3.0")
gamma = gamma_all[gIdx]
for (sIdx in 1:length(s_all)) {
s = s_all[sIdx]
sv = exp(-1 * (gamma * delay)^s );
lines(delay, sv, type="l",xlim=c(0,520), ylim=c(0,1), ylab="", xlab="", col=gIdx)
}
gamma = 0.1
plot(0, 0, xlim=c(0,520), ylim=c(0,1), type="l",
main = "CS (2 pars), gamma from 0.0005 to 0.3, s from 0.05 to 3.0")
for (sIdx in 1:length(s_all)) {
s = s_all[sIdx]
sv = exp(-1 * (gamma * delay)^s );
lines(delay, sv, type="l",xlim=c(0,520), ylim=c(0,1), ylab="", xlab="", col=gIdx)
}
gamma = 0.2
plot(0, 0, xlim=c(0,520), ylim=c(0,1), type="l",
main = "CS (2 pars), gamma from 0.0005 to 0.3, s from 0.05 to 3.0")
for (sIdx in 1:length(s_all)) {
s = s_all[sIdx]
sv = exp(-1 * (gamma * delay)^s );
lines(delay, sv, type="l",xlim=c(0,520), ylim=c(0,1), ylab="", xlab="", col=gIdx)
}
source('~/Dropbox/ADO_DD/ado_parameter_cs.R')
source('~/Dropbox/ADO_DD/ado_parameter_cs.R', echo=TRUE)
source('~/Dropbox/ADO_DD/ado_parameter_cs.R')
?seq
seq(0.005, 0.2, length.out = 20)
gamma_all = seq(0.0005, 0.2, by = 0.001);
gamma_all
source('~/Dropbox/ADO_DD/ado_parameter_cs.R')
gamma_all = c( seq(0.005, 0.01 by=0.001), seq(0.01, 0.2, by = 0.01) )
gamma_all = c( seq(0.005, 0.01, by=0.001), seq(0.01, 0.2, by = 0.01) )
length(gamma_all)
source('~/Dropbox/ADO_DD/ado_parameter_cs.R')
gamma_all
source('~/Dropbox/ADO_DD/ado_parameter_cs.R')
seq(0.005, 0.01, by=0.001)
rm(list=ls())
#delay = c(0.5, 1, 2, 3, 4, 8, 12, 26, 52, 156, 520);
delay = seq(0, 520, by = 1)
# gamma_all = seq(0.0005, 0.1, by = 0.0005);
# s_all = seq(0.05, 2.0, by = 0.05)
gamma_all = seq(0.0005, 0.2, by = 0.001);
#gamma_all = c( seq(0.005, 0.01, by=0.001), seq(0.01, 0.2, by = 0.01) )
s_all = seq(0.05, 2.0, by = 0.05)
quartz()
plot(0, 0, xlim=c(0,520), ylim=c(0,1), type="l",
main = "CS (2 pars), gamma from 0.0005 to 0.3, s from 0.05 to 3.0")
gIdx=1
gamma = gamma_all[gIdx]
gamma
source('~/Dropbox/ADO_DD/ado_parameter_cs.R')
lengthg(gamma_all)
length(gamma_all)
source('~/Dropbox/ADO_DD/ado_parameter_cs.R')
s_all = seq(0.05, 2.0, by = 0.1)
length(s_all)
iinstall.packages(edgeR)
iinstall.packages("edgeR")
source("https://bioconductor.org/biocLite.R")
biocLite("edgeR")
library(edgeR)
x = read.delim("fileofcounts.txt")
library(baySeq)
install.packages(baySeq)
source("https://bioconductor.org/biocLite.R")
biocLite("baySeq")
library(baySeq)
load("mobData.RData")
head(mobData)
load("https://bios221.stanford.edu/data/mobData.RData")
?load
load(url("https://bios221.stanford.edu/data/mobData.RData"))
head(mobData)
mobDataGroups <- c("MM", "MM", "WM", "WM", "WW", "WW")
data(mobAnnotation)
head(mobAnnotation)
d <- DGEList(counts=mobData,group=factor(mobDataGroups))
d
d.full <- d # keep the old one in case we mess up
head(d$counts)
head(cpm(d))
apply(d$counts, 2, sum) # total gene counts per sample
keep <- rowSums(cpm(d)>100) >= 2
d <- d[keep,]
dim(d)
d$samples$lib.size <- colSums(d$counts)
d$samples
d <- calcNormFactors(d)
d
dim(d)
plotMDS(d, method="bcv", col=as.numeric(d$samples$group))
d
d$samples
d
d[[1]]
dim(d[[1]])
dim(d[[2]])
dim(d[[3]])
dim
d
legend("bottomleft", as.character(unique(d$samples$group)), col=1:3, pch=20)
d1 <- estimateCommonDisp(d, verbose=T)
names(d1)
d1 <- estimateTagwiseDisp(d1)
plotBCV(d1)
install.packages("PMA")
library(PMA)
install.packages("impute")
source("https://bioconductor.org/biocLite.R")
biocLite("impute")
source("https://bioconductor.org/biocLite.R")
biocLite("impute")
library(PMA)
?"PMA-package"
??"PMA-package"
data(breastdata)
attach(breastdata)
PlotCGH(dna[,1], chrom=chrom, main="Sample 1", nuc=nuc)
detach(breastdata)
dim(dna)
dna
breastdata
length(breastdata)
data(breastdata)
attach(breastdata)
PlotCGH(dna[,1], chrom=chrom, main="Sample 1", nuc=nuc)
dim(dna)
head(dna)
clc
library(RWiener)
set.seed(0)dat <- rwiener(n=100, alpha=2, tau=.3, beta=.5, delta=.5)
set.seed(0)
dat <- rwiener(n=100, alpha=2, tau=.3, beta=.5, delta=.5)
dat
plot(dat)
dwiener(dat$q[1], alpha=2, tau=.3, beta=.5, delta=.5, resp=dat$resp[1], give_log=FALSE)
curve(dwiener(x, 2, .3, .5, .5, rep("upper", length(x))),      xlim=c(0,3), main="Density of upper responses",      ylab="density", xlab="quantile")
x
pwiener(dat$q[1], alpha=2, tau=.3, beta=.5, delta=.5, resp=dat$resp[1])
x <- c(2, .3, .5, .5)
wiener_likelihood(x=x, dat=dat)
dat
table(dat$resp)
hist(dat$q)
hist(dat$q, breaks=20)
dat <- rwiener(n=1000, alpha=2, tau=.3, beta=.5, delta=.5)
hist(dat$q, breaks=20)
optim1 <- optim(c(1, .1, .1, 1), wiener_deviance, dat=dat, method="Nelder-Mead")
optim1
#dat <- rwiener(n=100, alpha=2, tau=.3, beta=.5, delta=.5)
wiener_likelihood
dwiener
optim2 <- optim(optim1[["par"]], wiener_deviance, dat=dat, method="BFGS", hessian=TRUE)
optim1
optim2
nlm1 <- nlm(p=c(1, .1, .1, 1), f=wiener_deviance, dat=dat)
nlm1
when excluding a pure group
#     different file names for excluding/including a pure group
# v7: with dataset v6.. allows removing total scores and others..
#     poly is an option now
#     Improved color scheme!! (1/16/2015)
# v8: out-of-sample option... save files with v8, uses data v7, separately for amph and heroin predictions
#     binary: does logistic regression following Alex Todorov's suggestions.
#     removes HRBS-S from a list of regressors
# v9: don't use HRBS for sure. Exclude DRD_S_M
#     add Lane Omission error!
# v10: remove demographic variables
# v11: include demographic but exclude handedness....
# v12: exclude 5 bad subjects
# v13: try comparing pur
3487+6667
3487+6667+30
1000/30
1000/60
install.packages("twitteR")
library(twitteR)
keyword = "computational"
curri<-searchTwitter(keyword, lang="en", n=10000, since='2014-09-23')
?searchTwitteR
?searchTwitter
curri<-searchTwitter(keyword, n=10000, since='2014-09-23')
curri<-searchTwitter(keyword, n=10000)
curri<-searchTwitteR(keyword, n=10000)
install.packages("glmnet")
library(glmnet)
?glmnet
install.packages("h2o")
library(h20)
library(h2o)
??h2o
prostate
prosPath = system.file("extdata", "prostate.csv", package = "h2o")
prostate_df <- read.csv(prosPath)
prostate_df <- prostate_df[,-1]
summary(prostate_df)
set.seed(1234)
random_splits <- runif(nrow(prostate_df))
train_df <- prostate_df[random_splits < .5,]
dim(train_df)
validate_df <- prostate_df[random_splits >=.5,]
dim(validate_df)
install.packages('randomForest')
library(randomForest)
outcome_name <- 'CAPSULE'
feature_names <- setdiff(names(prostate_df), outcome_name)
set.seed(1234)
rf_model <- randomForest(x=train_df[,feature_names],
y=as.factor(train_df[,outcome_name]),
importance=TRUE, ntree=20, mtry = 3)
validate_predictions <- predict(rf_model, newdata=validate_df[,feature_names], type="prob")
library(pROC)
auc_rf = roc(response=as.numeric(as.factor(validate_df[,outcome_name]))-1,
predictor=validate_predictions[,2])
plot(auc_rf, print.thres = "best", main=paste('AUC:',round(auc_rf$auc[[1]],3)))
abline(h=1,col='blue')
abline(h=0,col='green')
localH2O = h2o.init()
prostate.hex<-as.h2o(train_df, destination_frame="train.hex")
prostate.dl = h2o.deeplearning(x = feature_names, training_frame = prostate.hex,
autoencoder = TRUE,
reproducible = T,
seed = 1234,
hidden = c(6,5,6), epochs = 50)
prostate.anon = h2o.anomaly(prostate.dl, prostate.hex, per_feature=FALSE)
head(prostate.anon)
err <- as.data.frame(prostate.anon)
plot(sort(err$Reconstruction.MSE), main='Reconstruction Error')
train_df_auto <- train_df[err$Reconstruction.MSE < 0.1,]
set.seed(1234)
rf_model <- randomForest(x=train_df_auto[,feature_names],
y=as.factor(train_df_auto[,outcome_name]),
importance=TRUE, ntree=20, mtry = 3)
validate_predictions_known <- predict(rf_model, newdata=validate_df[,feature_names], type="prob")
auc_rf = roc(response=as.numeric(as.factor(validate_df[,outcome_name]))-1,
predictor=validate_predictions_known[,2])
plot(auc_rf, print.thres = "best", main=paste('AUC:',round(auc_rf$auc[[1]],3)))
abline(h=1,col='blue')
abline(h=0,col='green')
train_df_auto <- train_df[err$Reconstruction.MSE >= 0.1,]
set.seed(1234)
rf_model <- randomForest(x=train_df_auto[,feature_names],
y=as.factor(train_df_auto[,outcome_name]),
importance=TRUE, ntree=20, mtry = 3)
validate_predictions_unknown <- predict(rf_model, newdata=validate_df[,feature_names], type="prob")
auc_rf = roc(response=as.numeric(as.factor(validate_df[,outcome_name]))-1,
predictor=validate_predictions_unknown[,2])
plot(auc_rf, print.thres = "best", main=paste('AUC:',round(auc_rf$auc[[1]],3)))
abline(h=1,col='blue')
abline(h=0,col='green')
valid_all <- (validate_predictions_known[,2] + validate_predictions_unknown[,2]) / 2
auc_rf = roc(response=as.numeric(as.factor(validate_df[,outcome_name]))-1,
predictor=valid_all)
plot(auc_rf, print.thres = "best", main=paste('AUC:',round(auc_rf$auc[[1]],3)))
abline(h=1,col='blue')
abline(h=0,col='green')
graphics.off()
update.packages("glinternet")
library(glinternet)
setwd("~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM_youngEdits/R")
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM_youngEdits/R/igt_vpp_old2.R')
output=igt_vpp(data= dataPath, niter = 1000, nwarmup = 500, inits = "fixed", pcomp = 2, nchains = 2, waic = T, email = "wooyoung.ahn@gmail.com")
dataPath = "/Users/wahn/Dropbox/CCSL/R_Package_Project/Package_Build/For_Testing/IGTdata_HC.txt"
getwd()
output=igt_vpp(data= dataPath, niter = 1000, nwarmup = 500, inits = "fixed", pcomp = 2, nchains = 2, waic = T, email = "wooyoung.ahn@gmail.com")
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM_youngEdits/R/waic_igt_vpp.R')
output=igt_vpp(data= dataPath, niter = 1000, nwarmup = 500, inits = "fixed", pcomp = 2, nchains = 2, waic = T, email = "wooyoung.ahn@gmail.com")
output$WAIC
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/Lei_Zhang/extract_ic.R')
extract_IC(output$fit)
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM_youngEdits/R/waic_igt_vpp.R')
woo=extract_IC(output$fit)
woo$WAIC
summary(woo$WAIC)
dim(woo$WAIC)
length(woo$WAIC)
woo$WAIC
library(mail)
sendmail("wooyoung.ahn@gmail.com", 'test', 'main')
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM_youngEdits/R/igt_vpp_old2.R')
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM_youngEdits/R/waic_igt_vpp.R')
woo=output$parVals
dim(woo$mu_A)
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM_youngEdits/R/waic_igt_vpp.R')
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM_youngEdits/R/igt_vpp_old2.R')
output=igt_vpp(data= dataPath, niter = 800, nwarmup = 500, inits = "fixed", pcomp = 2, nchains = 2, waic = T, email = "wooyoung.ahn@gmail.com")
output$WAIC
mean(output$WAIC)
sum(output$WAIC)
extract(output$fit)
extract_IC(output$fit)
library(loo)
youngWAIC = output$WAIC
lik    <- extract_log_lik(output$fit, parameter_name = 'log_lik')
waic(lik)
lik
dim(lik)
waic
UseMethod("waic")
?waic
apply(lik, 2, mean)
apply(lik, 2, mean)*2
apply(lik, 2, mean)*-2
youngWAIC
quartz();plot(apply(lik, 2, mean)*-2, youngWAIC)
extract_IC(output$fit)
sum(output$WAIC)
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM_youngEdits/R/igt_vpp.R')
dataPath = "/Users/wahn/Dropbox/CCSL/R_Package_Project/Package_Build/For_Testing/IGTdata_A_Sample.txt"
output=igt_vpp(data= dataPath, niter = 800, nwarmup = 500, inits = "random", pcomp = 2, nchains = 2, email = "wooyoung.ahn@gmail.com")
output$allIndPars
output$fit
extract_IC(output$fit)
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM_youngEdits/R/igt_pvl_delta.R')
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM_youngEdits/R/igt_pvl_decay.R')
output_delta=igt_pvl_delta(data= dataPath, niter = 800, nwarmup = 500, inits = "random", pcomp = 2, nchains = 2, email = "wooyoung.ahn@gmail.com")
extract_IC(output_delta$fit)
extract_IC(output$fit)
log_lik_vpp = extract_log_lik(output$fit)
log_lik_delta = extract_log_lik(output_delta$fit)
loo2_vpp = loo(log_lik_vpp)
loo2_delta = loo(log_lik_delta)
compare(loo2_vpp, loo2_delta)
compare(loo2_delta, loo2_vpp)
file.path(system.file(package='hBayesDM'),
'/stan/igt_pvl_decay.stan')
?system.file
system.file("inst", "igt_pvl_decay.stan", package="hBayesDM")
system.file("stan", "igt_pvl_decay.stan", package="hBayesDM")
system.file("inst/stan", "igt_pvl_decay.stan", package="hBayesDM")
system.file("inst", "igt_pvl_decay.stan", package="hBayesDM")
system.file("inst/stan/igt_pvl_decay.stan", package="hBayesDM")
system.file("stan/igt_pvl_decay.stan", package="hBayesDM")
system.file("stan", package="hBayesDM")
system.file("stan/igt_pvl_decay.stan", package="hBayesDM")
system.file("stan/igt_pvl_decay.stan", package="hBayesDM")
system.file("igt_pvl_decay.stan", package="hBayesDM")
system.file("stan", package="hBayesDM")
system.file("inst", package="hBayesDM")
system.file("stan", package="hBayesDM")
system.file("stan","igt_pvl_decay.stan", package="hBayesDM")
system.file("stan","igt_pvl_decay.stan", package="hBayesDM")
system.file("igt_pvl_decay.stan","stan", package="hBayesDM")
system.file("stan", package="hBayesDM")
system.file("igt_pvl","stan", package="hBayesDM")
system.file("igt_pvl_decay.stan","stan", package="hBayesDM")
system.file("gng_m1.stan","stan", package="hBayesDM")
system.file("stan","gng_m1.stan", package="hBayesDM")
system.file("stan","igt_pvl_decay.stan.stan", package="hBayesDM")
system.file("stan","igt_pvl_decay.stan", package="hBayesDM")
rstan:::rstudio_stanc("~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM/inst/stan/dd_cs.stan")
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDM/R/dd_cs.R')
library(hBayesDM)
output <- bandit2arm_delta(data = "example", niter = 2000, nwarmup = 1000, nchain = 3, ncore = 3)
output$fit
View(output$fit)
extract(output$fit, object = "Rhat")
str(output$fit)
plot(output, "trace")
plot(output)
plot(output)
plot(output)
output$fit
quartz(); plot(output)
?hBayesDM
extract(output$fit)
str(extract(output$fit))
?stan
plot(output$fit)
summary(output$fit)
print(output$fit)
print(output$fit, pars = "Rhat")
show(output$fit)
get_adaptation_info(output$fit)
get_adaptation_info(output$fit)
get_sampler_params(output$fit)
test <- get_sampler_params(output$fit)
test
test[[1]]
test[[1]]$acceptance_prob
test[[1]][[1]]
test[[1]][[2]]
test[[1]][,1]
mean(test[[1]][,1])
mean(test[[1]][,2])
mean(test[[1]][,3])
mean(test[[1]][,4])
mean(test[[1]][,5])
mean(test[[1]][,6])
mean(test[[1]][,7])
names(test[[1]])
dimnames(test[[1]])
test <- get_adaptation_info(output$fit)
test
test <- get_sampler_params(output$fit)
get_sampler_params(output$fit)
print(get_sampler_params(output$fit))
print(get_adaptation_info(output$fit))
print(get_all_vars(output$fit))
summary(output$fit)$summary[,"Rhat"]
summary(output$fit)
summary(output$fit)$summary[,1]
summary(output$fit)$summary[,2]
summary(output$fit)$summary[,3]
summary(output$fit)$summary[,4]
summary(output$fit)$summary[,5]
summary(output$fit)$summary[,6]
summary(output$fit)$summary[,7]
summary(output$fit)$summary[,"Rhat"]
summary(output$fit)$summary[,"lp__"]
summary(output$fit)$summary[,"n_eff"]
output$fit[,"Rhat"]
output$fit
output$fit[[1]]
class(output$fit) <- "hBayesDM"
output$fit[[1]]
class(output$fit)
class(output$fit) <- "stanfit"
output$fit
summary(output$fit)
summary(output$fit)$summary
summary(output$fit)$summary[,"Rhat"]
test<- summary(output$fit)$summary[,"Rhat"]
names(summary(output$fit)$summary[,"Rhat"])
test <- data.frame(parameter = names(summary(output$fit)$summary[,"Rhat"]), Rhat = summary(output$fit)$summary[,"Rhat"])
View(test)
test <- data.frame(Rhat = summary(output$fit)$summary[,"Rhat"])
View(test)
test
exists(...)
use <- ...
source('~/Dropbox/CCSL/R_Package_Project/Package_Build/hBayesDMdev/R/rhats.R')
rhats(output)
rhats(output, 1.1)
rhats(output, 1.0)
rhats(output, 1.01)
rhats(output)
rhats(output, less = 1.1)
